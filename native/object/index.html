<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="x5-fullscreen" content="true"><meta name="full-screen" content="yes"><meta name="theme-color" content="#317EFB"><meta content="width=device-width,initial-scale=1,maximum-scale=5,user-scalable=0" name="viewport"><meta name="description" content="前端原生，前端对象，原生js，JavaScript"><meta property="og:type" content="article"><meta property="og:title" content="前端原生【对象】Object"><meta property="og:url" content="https://www.yangchenyu.com/native/object/index.html"><meta property="og:site_name"><meta property="og:description" content="前端原生，前端对象，原生js，JavaScript"><meta property="og:locale"><meta property="article:published_time" content="2019-10-11T03:26:32.000Z"><meta property="article:modified_time" content="2023-06-09T08:25:14.008Z"><meta property="article:author" content="CHENY"><meta property="article:tag" content="前端"><meta name="twitter:card" content="summary"><meta name="keywords" content="前端对象、前端原生、JavaScript、原生js"><title>前端原生【对象】Object</title><link href="/favicon-16x16.png?v=1.2.14" rel="icon" type="image/png" sizes="16x16"><link href="/favicon-32x32.png?v=1.2.14" rel="icon" type="image/png" sizes="32x32"><link href="/apple-touch-icon.png?v=1.2.14" rel="apple-touch-icon" sizes="180x180"><link href="/site.webmanifest" rel="manifest"><link rel="stylesheet" href="/css/plugins/bootstrap.row.css"><link rel="stylesheet" href="https://unpkg.com/locomotive-scroll@4.1.4/dist/locomotive-scroll.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.css"><link rel="stylesheet" href="/css/plugins/font-awesome.min.css"><script>window.ASYNC_CONFIG={hostname:"www.yangchenyu.com",author:"CHENY",root:"/",typed_text:["Aspirant Developer"],favicon:{logo:"https://cheny-chenyu.oss-cn-chengdu.aliyuncs.com/img/blog-logo.png",icon16:"favicon-16x16.png",icon32:"favicon-32x32.png",appleTouchIcon:"apple-touch-icon.png",webmanifest:"/site.webmanifest",visibilitychange:!1,hidden:"/failure.ico",showText:"(/≧▽≦/)咦！又好了！",hideText:"(●—●)喔哟，崩溃啦！"},theme_version:"1.2.14",theme:{switch:!0,default:"auto"},search:{enable:!0,type:"local",href:"https://www.google.com/search?q=site:",domain:null,preload:!0,trigger:"auto",path:"search.xml"},i18n:{placeholder:"搜索...",empty:"找不到您查询的内容: ${query}",hits:"找到 ${hits} 条结果",hits_time:"找到 ${hits} 条结果（用时 ${time} 毫秒）",author:"本文作者：",copyright_link:"本文链接：",copyright_license_title:"版权声明：",copyright_license_content:"本博客所有文章除特别声明外，均默认采用 undefined 许可协议。",copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败",open_read_mode:"进入阅读模式",exit_read_mode:"退出阅读模式"},creative_commons:{license:"by-nc-sa",language:"deed.zh",post:!0,clipboard:!1},swup:!0,plugin:{flickr_justified_gallery:{js:"https://unpkg.com/flickr-justified-gallery@latest/dist/fjGallery.min.js"},fancybox:{css:"https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.css",js:"https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"}},icons:{sun:"far fa-sun",moon:"far fa-moon",play:"fas fa-play",email:"far fa-envelope",next:"fas fa-arrow-right",calendar:"far fa-calendar-alt",clock:"far fa-clock",user:"far fa-user",back_top:"fas fa-arrow-up",close:"fas fa-times",search:"fas fa-search",reward:"fas fa-hand-holding-usd",user_tag:"fas fa-user-alt",toc_tag:"fas fa-th-list",read:"fas fa-book-reader",arrows:"fas fa-arrows-alt-h"}}</script><link data-swup-theme rel="stylesheet" href="/css/index.css?v=1.2.14" id="trm-switch-style"><script>let defaultMode="auto"!==ASYNC_CONFIG.theme.default?ASYNC_CONFIG.theme.default:window.matchMedia("(prefers-color-scheme: light)").matches?"style-light":"style-dark",catchMode=localStorage.getItem("theme-mode")||defaultMode,type="style-dark"===catchMode?"add":"remove";document.documentElement.classList[type]("dark")</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?bbad9d8e1fd8e044d365c2ce0d114c73";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="null" type="application/atom+xml">
</head><body><div class="trm-app-frame"><div class="trm-preloader"><div class="trm-holder"><div class="preloader"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></div><div class="trm-mode-swich-animation-frame"><div class="trm-mode-swich-animation"><i class="i-sun"><i class="iconfont far fa-sun"></i></i><div class="trm-horizon"></div><i class="i-moon"><i class="iconfont far fa-moon"></i></i></div></div><div id="trm-dynamic-content" class="trm-swup-animation"><div id="trm-scroll-container" class="trm-scroll-container" data-scroll-container style="opacity:0"><div data-scroll-section id="content" class="trm-scroll-section"><div class="locomotive-scroll__sticky-target" style="position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none"></div><header class="trm-top-bar" data-scroll data-scroll-sticky data-scroll-target=".locomotive-scroll__sticky-target" data-scroll-offset="-10"><div class="container"><div class="trm-left-side"><a href="/" class="trm-logo-frame trm-anima-link"><img alt="logo" src="https://cheny-chenyu.oss-cn-chengdu.aliyuncs.com/img/blog-logo.png"></a></div><div class="trm-right-side"><div class="trm-menu"><nav><ul><li class="menu-item-has-children"><a href="/" target="">Home</a></li><li class="menu-item-has-children"><a href="/archives/" target="">Archives</a></li><li class="menu-item-has-children"><a href="/links/" target="">Links</a></li><li class="menu-item-has-children"><a href="/about/" target="">About</a><ul><li><a href="/projects/" target="">Projects</a></li><li><a data-no-swup href="https://foreverblog.cn/go.html" target="_blank">Forever Go</a></li></ul></li></ul></nav></div><div class="trm-mode-switcher-place"><div class="trm-mode-switcher"><i class="iconfont far fa-sun"></i> <input class="tgl tgl-light" id="trm-swich" type="checkbox"> <label class="trm-swich" for="trm-swich"></label> <i class="iconfont far fa-moon"></i></div></div><div id="trm-search-btn" class="trm-search-btn"><i class="iconfont fas fa-search"></i></div></div><div class="trm-menu-btn"><span></span></div></div></header><div class="trm-content-start"><div class="trm-banner" data-scroll data-scroll-direction="vertical"><img style="object-position:top;object-fit:cover" alt="banner" class="trm-banner-cover" data-scroll data-scroll-direction="vertical" data-scroll-speed="-3" src="/img/banner.png"><div class="trm-banner-content trm-overlay"><div class="container" data-scroll data-scroll-direction="vertical" data-scroll-speed="0"><div class="row"><div class="col-lg-4"></div><div class="col-lg-8"><div class="trm-banner-text"><div class="trm-label trm-mb-20">NEWS LETTER</div><h1 class="trm-mb-30 trm-hsmb-font">前端原生【对象】Object</h1><ul class="trm-breadcrumbs trm-label"><li><a href="/" class="trm-anima-link">Home</a></li><li><span>native</span></li></ul></div><a href="#about-triger" data-scroll-to="#about-triger" data-scroll-offset="-130" class="trm-scroll-hint-frame"><div class="trm-scroll-hint"></div><span class="trm-label">Scroll down</span></a></div></div></div></div></div><div class="container"><div class="row"><div id="page-sidebar" class="col-lg-4 hidden-sm"><div class="trm-main-card-frame trm-sidebar"><div class="trm-main-card" data-scroll data-scroll-repeat data-scroll-sticky data-scroll-target=".locomotive-scroll__sticky-target" data-scroll-offset="60"><div class="trm-user-tabs" id="sidebar-tabs"><div class="trm-tabs-nav trm-mb-40" id="trm-tabs-nav"><div data-to="tabs-user" class="trm-tabs-nav-item"><i class="iconfont fas fa-user-alt"></i></div><div data-to="tabs-toc" class="trm-tabs-nav-item active"><i class="iconfont fas fa-th-list"></i></div></div><div name="tabs-user" class="trm-tabs-item"><div class="trm-mc-header"><div class="trm-avatar-frame trm-mb-20"><img alt="Avatar" class="trm-avatar" src="https://cheny-chenyu.oss-cn-chengdu.aliyuncs.com/img/ip.jpg"></div><h5 class="trm-name trm-mb-15">CHENY</h5><div class="trm-label">I`m <span class="trm-typed-text"></span></div></div><div class="trm-divider trm-mb-40 trm-mt-40"></div><div class="trm-social"><a href="https://github.com/ChenyCHENYU" title="Github" rel="nofollow" target="_blank"><i class="iconfont fab fa-github"></i> </a><a href="https://gitee.com/ycyplus163" title="Gitee" rel="nofollow" target="_blank"><i class="iconfont fab fa-github-alt"></i> </a><a href="https://www.tzagileteam.com/" title="AgileTeam" rel="nofollow" target="_blank"><i class="iconfont fas fa-blog"></i></a></div><div class="trm-divider trm-mb-40 trm-mt-40"></div><ul class="trm-table trm-mb-20"><li><div class="trm-label">Residence:</div><div class="trm-label trm-label-light">China</div></li><li><div class="trm-label">City:</div><div class="trm-label trm-label-light">Xi'An</div></li><li><div class="trm-label">Age:</div><div class="trm-label trm-label-light">33</div></li></ul><div class="trm-divider trm-mb-40 trm-mt-40"></div><div class="text-center"><a href="mailto:ycyplus@gmail.com" class="trm-btn">联系我 <i class="iconfont far fa-envelope"></i></a></div></div><div name="tabs-toc" class="trm-tabs-item active"><div class="post-toc"><ol class="toc"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#对象的属性类型" data-scroll-to="#对象的属性类型"><span class="toc-number">1.</span> <span class="toc-text">对象的属性类型</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#属性特征：（数据属性）" data-scroll-to="#属性特征：（数据属性）"><span class="toc-number">2.</span> <span class="toc-text">属性特征：（数据属性）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a rel="nofollow" class="toc-link" href="#通用特征" data-scroll-to="#通用特征"><span class="toc-number">2.1.</span> <span class="toc-text">通用特征</span></a></li><li class="toc-item toc-level-3"><a rel="nofollow" class="toc-link" href="#数据属性的特征" data-scroll-to="#数据属性的特征"><span class="toc-number">2.2.</span> <span class="toc-text">数据属性的特征</span></a></li><li class="toc-item toc-level-3"><a rel="nofollow" class="toc-link" href="#访问器属性特征" data-scroll-to="#访问器属性特征"><span class="toc-number">2.3.</span> <span class="toc-text">访问器属性特征</span></a></li><li class="toc-item toc-level-3"><a rel="nofollow" class="toc-link" href="#获取（读取）属性特征" data-scroll-to="#获取（读取）属性特征"><span class="toc-number">2.4.</span> <span class="toc-text">获取（读取）属性特征</span></a></li><li class="toc-item toc-level-3"><a rel="nofollow" class="toc-link" href="#定义多重属性" data-scroll-to="#定义多重属性"><span class="toc-number">2.5.</span> <span class="toc-text">定义多重属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#继承自-Object-prototype-的方法" data-scroll-to="#继承自-Object-prototype-的方法"><span class="toc-number">3.</span> <span class="toc-text">继承自 Object.prototype 的方法</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#判断某个对象是否是另外一个对象的原型" data-scroll-to="#判断某个对象是否是另外一个对象的原型"><span class="toc-number">4.</span> <span class="toc-text">判断某个对象是否是另外一个对象的原型</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#Object-create-方法" data-scroll-to="#Object-create-方法"><span class="toc-number">5.</span> <span class="toc-text">Object.create() 方法</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#禁止修改对象" data-scroll-to="#禁止修改对象"><span class="toc-number">6.</span> <span class="toc-text">禁止修改对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a rel="nofollow" class="toc-link" href="#禁止扩展：Object-preventExtensions" data-scroll-to="#禁止扩展：Object-preventExtensions"><span class="toc-number">6.1.</span> <span class="toc-text">禁止扩展：Object.preventExtensions()</span></a></li><li class="toc-item toc-level-3"><a rel="nofollow" class="toc-link" href="#对象封印：Object-seal" data-scroll-to="#对象封印：Object-seal"><span class="toc-number">6.2.</span> <span class="toc-text">对象封印：Object.seal()</span></a></li><li class="toc-item toc-level-3"><a rel="nofollow" class="toc-link" href="#对象冻结-Object-fieeze" data-scroll-to="#对象冻结-Object-fieeze"><span class="toc-number">6.3.</span> <span class="toc-text">对象冻结 Object.fieeze()</span></a></li></ol></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#模块模式和暴露模块模式" data-scroll-to="#模块模式和暴露模块模式"><span class="toc-number">7.</span> <span class="toc-text">模块模式和暴露模块模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a rel="nofollow" class="toc-link" href="#暴露模块模式" data-scroll-to="#暴露模块模式"><span class="toc-number">7.1.</span> <span class="toc-text">暴露模块模式</span></a></li><li class="toc-item toc-level-3"><a rel="nofollow" class="toc-link" href="#构造函数的私有成员" data-scroll-to="#构造函数的私有成员"><span class="toc-number">7.2.</span> <span class="toc-text">构造函数的私有成员</span></a></li></ol></li></ol></div></div></div></div></div></div><div id="page-content" class="col-lg-8"><div class="trm-content" id="trm-content"><div data-scroll data-scroll-repeat data-scroll-offset="500" id="about-triger"></div><div id="post-info" class="row hidden-sm"><div class="col-sm-4"><div class="trm-card trm-label trm-label-light text-center"><i class="iconfont far fa-calendar-alt trm-icon"></i><br>10/11</div></div><div class="col-sm-4"><div class="trm-card trm-label trm-label-light text-center"><i class="iconfont far fa-clock trm-icon"></i><br>11:26</div></div><div class="col-sm-4"><div id="post-author" class="trm-card trm-label trm-label-light text-center"><i class="iconfont far fa-user trm-icon"></i><br>CHENY</div></div></div><div class="trm-card"><article id="article-container" class="trm-publication"><blockquote><p>练武不练功，到头一场空，JavaScript 原生对象，被业务应用层的研发容易忽略的一些底层细节。</p></blockquote><h2 id="对象的属性类型"><a href="#对象的属性类型" class="headerlink" title="对象的属性类型"></a>对象的属性类型</h2><p>属性有两种类型：数据类型和访问器类型。</p><ul><li>数据属性包含一个值，比如自己定义的 name,sex,age 等，而对象里有一个内置的 [[Put]] 方法，它的默认行为是创建数据属性；</li><li>访问器属性不包含值而是定义了一个当属性被读取时调用的函数(称为 getter)和一个当属性被写入时调用的函数(称为 setter)。</li></ul><p>访问器属性仅需要 <code>getter</code>和 <code>setter</code> 两者中的任意一个，当然也可以两者都有。</p><p>在对象字面形式中定义访问器属性有特殊的语法：<br>例：访问器类型 ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&#x27;YangYangYang&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在get,设定访问器读取属性name&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在set,设定访问器设置属性name：&#x27;</span>, value)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = value</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>)</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;Greg&#x27;</span> <span class="comment">// 这里设置属性name 触发了内置的set 直接</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><p>使用场景：当你希望对象的赋值操作会触发一些行为或读取的值需要通过计算所需的返回值得到时，访问器属性会非常有用！</p><p><strong>补充：利用访问器属性 实现表单双向数据绑定</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;txt&#x27;</span>),</span><br><span class="line">  sp = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;sp&#x27;</span>),</span><br><span class="line">  obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给对象obj添加msg属性，并设置setter访问器</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;msg&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 设置 obj.msg  当obj.msg反生改变时set方法将会被调用</span></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 当obj.msg被赋值时 同时设置给 input/span</span></span><br><span class="line">    txt.<span class="property">value</span> = newVal</span><br><span class="line">    sp.<span class="property">innerText</span> = newVal</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听文本框的改变 当文本框输入内容时 改变obj.msg</span></span><br><span class="line">txt.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  obj.<span class="property">msg</span> = event.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="属性特征：（数据属性）"><a href="#属性特征：（数据属性）" class="headerlink" title="属性特征：（数据属性）"></a>属性特征：（数据属性）</h2><p>数据属性和访问器属性的特征</p><h3 id="通用特征"><a href="#通用特征" class="headerlink" title="通用特征"></a>通用特征</h3><hr><p>有两个属性特征是数据和访问属性都具有的。</p><ol><li>[[Enumerable]] (可枚举的)：决定了你是否可以遍历该属性；</li><li>[[Configurable]] (可配置的)：决定了该属性是否可配置；<br>配置的意思就是：你可以用 <code>delete</code> 删除一个可配置的属性，或者随时更改它，开放的！所有自己申明的对象属性默认都是可枚举、配置的！</li></ol><hr><p><strong>改变属性特征：Object.defineProperty() ===&gt; 译(定义属性的意思)</strong></p><p>使用 <code>Object.defineProperty</code> 方法如果不指定，除了 <code>value</code> 其他都时 <code>false</code></p><ol><li>拥有该属性的对象（属性所在的对象）；</li><li>属性名；</li><li>包含需要设置的特征的属性描述对象；<br>🔔 注意：参数三：3) 是一个对象{} 这个对象里面有四个属性:<br>第一个属性：<code>value</code> 指定的第二个参数的值 (可选)<br>第二个属性：<code>enumerable</code> 是否可枚举<br>第三个属性：<code>configurable</code> 是否可配置 (配置是指 可否删除? 可否重新定义) 类似于总开关<br>第四个属性：<code>wriable</code> 是否可写入 就是是否可以更改属性值等</li></ol><p>🔔 注意：configurable 修改为 false 以后 除了 <code>wriable</code> 其他都是不可逆的，不可重新配置的</p><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;YangYangYang&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制定义让该对象的name属性不可被枚举：</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person1, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">// 这句话代表不可枚举;  严格来说是:person1这个对象当中</span></span><br><span class="line">  <span class="comment">// 的name属性 不可被枚举;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> person1) <span class="comment">// true  判断对象当中 有没有这个属性可以用in,但是in不能过滤继承来的原型属性和方法;严格的话用hasOwnProperty()方法;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// false 注意：propertyIsEnumerable是用来判断这个属性是否可以被枚举的内置方法，返回布尔值;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把当前对象person1的所有键值对的键，也就是属性，放入一个数组当中！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> properties = <span class="title class_">Object</span>.<span class="title function_">keys</span>(person1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(properties) <span class="comment">// [] 因为上面的属性 只有一个name,而且name被限制为不可枚举，所以得到的会是一个空数组;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(properties.<span class="property">length</span>) <span class="comment">// 所以长度自然为0 ;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------  分割线</span></span><br><span class="line"><span class="comment">// 强制定义让该对象的name属性为不可设置(配置),也就是不可被修改</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person1, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 这句话的意思是 可写的 就是可以修改属性的值 默认是true可以修改 但是为false 值就不可被修改</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改值</span></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;你大爷&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试删除person1对象当中的name属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.<span class="property">name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> person1) <span class="comment">// 结果没被删除掉 结果不是undefined 而是true 代表属性在当前对象中存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：下面我尝试将配置开放，使其可以删除</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person1, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是抛出了一个 error错误！说明无法将一个不可配置的属性变成可配置，同样，在不可配置的情况下试图将数据属性编为访问器属性或反向变更也会抛出错误！</span></span><br></pre></td></tr></table></figure><p><strong>总结：可配置属性的这个 <code>Object.defineProperty()</code> 这个方法 是一次性的！在定义对象的时候，只起一次效果！不存在覆盖情况！🔔 最后注意 如果使用了属性类型的 <code>get</code> 和 <code>set</code> 方法就不能使用 <code>writable</code> 和 <code>value</code> 的任意一个 否则报错！</strong></p><h3 id="数据属性的特征"><a href="#数据属性的特征" class="headerlink" title="数据属性的特征"></a>数据属性的特征</h3><hr><p>数据属性额外拥有两个访问器属性不具备的特征</p><ol><li>[[Value]] : 包含属性的值，当你在对象上创建属性时该特征被自动赋值，匹配属性的值，键值对的值，对象中所有的属性的值都保存在 [[Value]] 中，哪怕该值是一个函数。</li><li>[[Wriable]]：该特征是一个布尔值，指示该属性是否可以写入。所以属性默认是可写的，除非另外指定<br>通过这两个额外特征，数据属性相当于拥有完整的四个属性特征；就是 <code>Object.defineProperty()</code> 方法的第三个参数里面的四个完整的参数！</li></ol><hr><p>所以常规的一个对象创建，并给这个对象添加属性以及属性值（就是添加键值对的过程）</p><p><strong>显式的是这样子：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;YangYangYang&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个很简单 就是创建了一个对象 给它添加了一个属性以及属性值，但是实际隐式机制创建是下面这样子</span></span><br></pre></td></tr></table></figure><p><strong>隐式的是这样子：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;&#125; <span class="comment">// 这里还有var person1 = new Object();</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person1, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;YangYangYang&#x27;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可配置</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">// 可写入</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意一点：当 <code>Object.defineProperty()</code>被调用时，它首先先检查属性是否存在，如果不存在，将根据属性描述对象指定的特征创建！如果使用 <code>Object.defineProperty()</code>方法给对象添加属性以及值，如果不针对参数进行设置，那么它们将默认都为 <code>false</code> 不可枚举、不可配置、不可修改！</strong></p><h3 id="访问器属性特征"><a href="#访问器属性特征" class="headerlink" title="访问器属性特征"></a>访问器属性特征</h3><hr><p>访问器属性也有两个额外特征。访问器属性不需要存储值，因为也就不需要(没有) [[Value]] 和 [[Wriable]]。取而代之的是[[Get]] 和 [[Set]],内含 <code>getter</code> 和 <code>setter</code> 函数。和对象字面形式的 <code>getter</code> 和 <code>setter</code> 一样，仅需要定义其中一个特征就可以创建一个访问器属性 。<br>🔔 注意：如果试图创建一个同时具有数据特征和访问器特征的属性，将会得到一个错误！</p><hr><p>在属性类型笔记里面的例子 可以改写为如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&#x27;YangYangYang&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person1, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在get设定访问器的读取属性name&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在set设定访问器设置属性name:&#x27;</span>, value)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同样使使这个访问器 可枚举、可配置</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>🔔 注意：这里传给 <code>Object.defineProperty()</code> 的属性描述对象中的 <code>get,set</code> 关键字属性，它们是包含函数的数据属性，在这里不能使用属性类型笔记中的那种对象字面形式的特殊设置方法 <code>set()&#123;&#125;</code>,<code>get()&#123;&#125;</code>。<br>🔔 注意：这里访问器属性如果不在 <code>Object.defineProperty()</code>方法中设置枚举以及配置为 <code>true</code> 默认任何调用 <code>Object.defineProperty()</code>方法的对象，里面指定的第二个参数属性，都是不可枚举，不可配置的！</p><p>和对象字面字面形式定义的访问器属性一样，在严格模式下试图写入没有 <code>setter</code> 的访问器属性会抛出错误，在非严格模式下会失效(什么也不弹出)，试图读取一个没有 <code>getter</code> 的访问器属性则总是返回 <code>undefined。</code></p><h3 id="获取（读取）属性特征"><a href="#获取（读取）属性特征" class="headerlink" title="获取（读取）属性特征"></a>获取（读取）属性特征</h3><p><code>Object.getOwnPropertyDescriptor()</code> 方法<br>此方法只可用于自有属性，接收两个参数：</p><ol><li>对象；</li><li>属性名；<br>如果属性存在，则返回一个属性描述对象，内含 4 个属性：<code>configurable</code> 和 <code>enumerable</code>;另外两个属性则根据属性类型决定，看是数据属性还是访问器属性！</li></ol><p>🔔 注意：如果是访问器属性，这个对象属性有 <code>configurable</code>、<code>enumerable</code>、<code>get</code>、<code>set</code>；<br>如果是数据属性，这个个对象属性有 <code>configurable</code>、<code>enumerable</code>、<code>writable</code> 和 <code>value</code>。</p><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;YangYangYang&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person1, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">enumerable</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">configurable</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">writable</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">value</span>) <span class="comment">// YangYangYang</span></span><br></pre></td></tr></table></figure><p>这里，属性 <code>name</code> 作为对象字面形式的一部分被定义。调用 <code>Object.getOwnPropertyDescriptor()</code> 方法返回的属性描述对象具有 4 个属性，因为上面是数据属性，所以返回 <code>enumerable</code>,<code>configurable</code>,<code>writable</code> 和 <code>value</code>,即使它们从没有没 <code>Object.defineProperty()</code>显式定义。</p><h3 id="定义多重属性"><a href="#定义多重属性" class="headerlink" title="定义多重属性"></a>定义多重属性</h3><hr><p>如果使用 Object.defineProperties() 方法而不是 Object.defineProperty() 方法，可以为一个对象同时定义多个属性。<br>Object.defineProperties() 接收两个参数：</p><ol><li>需要改变的对象；</li><li>一个包含所有属性信息的对象；(对象的属性与第一个参数对象要添加或修改的一一对应)</li></ol><hr><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(person1, &#123;</span><br><span class="line">  <span class="comment">// 属性来存储数据</span></span><br><span class="line">  <span class="attr">_name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;YangYnagYang&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 如果需要 继续往下写 比如age:&#123;&#125;,sex:&#123;&#125;等等 ，访问器数据一样</span></span><br><span class="line">  <span class="comment">// 访问器属性</span></span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设定获取&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设定设置&#x27;</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_name</span> = value</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>🔔 注意：上面代码 name 是对象里面属性的名字，设置有两种方式，一种利用 for in 循环 让所有属性匹配数据属性，或者如上一个一个去设置，上面仅设置了 name 属性，假设对象当中有 name 属性的话！</p><h2 id="继承自-Object-prototype-的方法"><a href="#继承自-Object-prototype-的方法" class="headerlink" title="继承自 Object.prototype 的方法"></a>继承自 Object.prototype 的方法</h2><p>所有的对象都继承顶级对象 Object.prototype 下面的 5 种方法</p><ul><li><p>hasOwnPrototype() 方法： 检查是否存在一个给定名字的自有属性（用来判断和过滤继承属性的）</p></li><li><p>propertyEnumerable() 方法：检查一个自有属性是否可枚举</p></li><li><p>isPrototypeOf() 方法：检查一个对象是否是另外一个对象的原型对象 （具体可参考笔记）</p></li><li><p>valueOf() 返回一个对象的值表达 (返回指定对象的原始值)</p></li><li><p>toString() 返回一个对象的字符串表达式，强大之处能把数组嵌套 N 层的强制转成字符串表达（隐）</p></li></ul><p>这 5 种方法由继承出现在所有对象中，也就是所有对象都可以使用这 5 种方法。</p><h2 id="判断某个对象是否是另外一个对象的原型"><a href="#判断某个对象是否是另外一个对象的原型" class="headerlink" title="判断某个对象是否是另外一个对象的原型"></a>判断某个对象是否是另外一个对象的原型</h2><p><code>isPrototypeOf()</code> 以及 <code>Object.getPrototypeOf()</code></p><p>通过 isPrototypeOf() 来确定对象之间是否存在这种关系，本质上讲，如果[[Prototype]] (就是<strong>proto</strong>) 指向调用 <code>isPrototypeOf()</code> 方法的对象 (<code>Person.prototype</code>)，那么这个方法就返回 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person1), <span class="comment">// true</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person2) <span class="comment">// true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里，用原型对象的 <code>isPrototypeOf()</code> 方法测试了 person1 和 person2 ，因为它们内部都有一个指向 <code>Person.prototype</code> 的指针，因此返回 <code>true</code></p><p><strong>isPrototypeOf(需要判断的对象名)</strong><br>该方法被包含在所有对象中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(obj)) <span class="comment">// 结果为true</span></span><br><span class="line"><span class="comment">// 任何实例化的对象，包括被new的对象它的隐式原型__proto__也就是[[Prototype]]</span></span><br><span class="line"><span class="comment">// 都指向了创建这个实例对象的构造函数的原型！这里创建obj实例对象的构造函数是</span></span><br><span class="line"><span class="comment">// Object 而实例对象的隐式原型指向了这个构造函数的原型Object.prototype;</span></span><br></pre></td></tr></table></figure><p>🔔 注意：可以使用 <code>Object.getPrototypeOf()</code> 方法读取 <code>__proto__</code> 也就是 [[Prototype]] 隐式原型属性的值</p><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) <span class="comment">// 实例对象通过getprototypeOf() 获取实例对象的隐式原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proto) <span class="comment">// 同下面的一样</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>) <span class="comment">// 同上面的一样</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proto === obj.<span class="property">__proto__</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// ------------- 分割线</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">constructor</span> === <span class="title class_">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proto === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 任何一个实例化的对象 隐式原型__proto__ 总是指向了Object顶级对象的原型prototype</span></span><br></pre></td></tr></table></figure><p>🔔 注意：上面代码 Object.getPrototypeOf(obj)得到的其实就是 obj 实例对象的 <code>__proto__</code></p><p>拓展：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="comment">// true</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person1) <span class="comment">// true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>返回的对象实际就是这个对象的原型。</p><h2 id="Object-create-方法"><a href="#Object-create-方法" class="headerlink" title="Object.create() 方法"></a>Object.create() 方法</h2><hr><p>该方法接收接收两个参数：</p><ol><li>要继承的对象，也就是说，要通过原型链 <code>__proto__</code>也就是 [[prototype]] 往上查找的对象</li><li>可选参数：属性的描述对象，描述属性特征！是否枚举？是否可配置？是否可读写？以及 value<br>如果第二个参数使用了不写，默认为 <code>false</code></li></ol><hr><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jonly&#x27;</span>,</span><br><span class="line">    <span class="attr">firends</span>: [<span class="string">&#x27;Luna&#x27;</span>, <span class="string">&#x27;Eva&#x27;</span>, <span class="string">&#x27;Van&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(person, &#123;</span><br><span class="line">   <span class="attr">name</span>:&#123;</span><br><span class="line">       <span class="attr">value</span>:<span class="string">&#x27;Jonly哥&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">firends</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)); /</span><br><span class="line"><span class="comment">// Object.create() 不可枚举 不可扩展 不可写入</span></span><br></pre></td></tr></table></figure><p>常规对象字面量方式创建对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我是这个对象的描述哈&#x27;</span>,</span><br><span class="line">&#125; <span class="comment">// 这种创建方式 字面量创建方式 该对象自动继承Object.prototype,并且其属性被</span></span><br><span class="line"><span class="comment">// 默认设置为 可配置、可枚举、没读写</span></span><br></pre></td></tr></table></figure><p>Object.create() 方式创建对象:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="comment">// 第一个参数要继承的对象</span></span><br><span class="line">  <span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可配置</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;我是当前这个book对象里面title属性的值撒&#x27;</span>,</span><br><span class="line">    <span class="attr">writeable</span>: <span class="literal">true</span>, <span class="comment">// 可读写</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>🔔 注意：以上两种申明方式具有相同的效果。</p><ul><li>第一种申明使用对象字面形式来定义一个具有单一属性的 <code>title</code> 的对象，该对象自动继承 <code>Objec.prototype</code>，并且其属性默认为可配置、可枚举、可读写！</li><li>第二种申明使用 <code>Object.create()</code> 显式做了同样的操作，两个 BOOK 行为完全一致！</li></ul><p><strong>下面的例子是用来体验 Object.crate() 来对象之间发生继承关系：</strong><br>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;YangYangYang&quot;</span>,</span><br><span class="line">    <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person1,&#123;  <span class="comment">// 指定继承person1</span></span><br><span class="line">    <span class="attr">name</span>:&#123;</span><br><span class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>:<span class="string">&quot;Greg&quot;</span>,</span><br><span class="line">        <span class="attr">writeable</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// YangYangYang</span></span><br><span class="line">person2.<span class="title function_">syaName</span>(); <span class="comment">// Greg  自己有name 就使用自己的 没有再去继承关系找</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;sayName)); // true sayName是person1的自有属性</span></span><br><span class="line"><span class="string">console.log(person1.isPrototypeOf(person2)); // true person2是继承person1</span></span><br><span class="line"><span class="string">console.log(person2.hasOwnProperty(&quot;</span>sayName<span class="string">&quot;)) // false 这个不是person2自有的属性</span></span><br></pre></td></tr></table></figure><p>当访问一个对象的属性时，javascript 引擎会执行一个搜索过程，如果在对象实例上发现该属性（就是自有属性），该属性值就会被使用。如果对象实例上没有发现该属性，则通过 [[prototype]] 也就是 <code>__proto__</code> 查找，如果也没有，则继续搜索该原型对象的<code>__proto__</code>,直接原型链顶端，<code>Object.prototype.__proto__</code> 为 <code>null</code>；</p><p>🔔 注意反例：不要使其为 null;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nakeObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> nakeObj) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span> <span class="keyword">in</span> nakObj) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 这是一个恶趣味的javascript诡计，创建了一个没有原型的对象，一个哈希容器;</span></span><br><span class="line"><span class="comment">// 这样导致Object.prototype的5个对象继承的原型方法toString,valueOf,hasProperty,</span></span><br><span class="line"><span class="comment">// isProtypeOf(检查一个对象是否另一个对象的原型对象),propertyIsEnumerable(检查</span></span><br><span class="line"><span class="comment">// 一个对象是否可以被枚举);</span></span><br></pre></td></tr></table></figure><p><strong>延申，用来实现继承父类原型的时候可以使用：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将父类的原型 赋值缓存到一个变量</span></span><br><span class="line"><span class="keyword">var</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">SuperClass</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// 这个原型的构造器 指向子类的构造函数</span></span><br><span class="line">prototype.<span class="property">constructor</span> = <span class="title class_">SubClass</span></span><br><span class="line"><span class="comment">// 将这个继承来的原型 放入子类自己的原型对象中</span></span><br><span class="line"><span class="title class_">SubClass</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype</span><br></pre></td></tr></table></figure><p><strong>设置原型继承 ES6 这个方法更加强大 <code>Object.setPrototypeOf(Son.prototype,Person.prototype)</code></strong></p><h2 id="禁止修改对象"><a href="#禁止修改对象" class="headerlink" title="禁止修改对象"></a>禁止修改对象</h2><hr><p>对象和属性一样具有指导其他行为的内部特征。其中对象内部 [[Extensible]] (可扩展的)是一个布尔值，它指明该对象本身是否可以被修改。所有创建的默认对象都是可扩展修改的，意味着新的属性可以随时添加。<br>设置 [[Extensible]] 为 <code>false</code>,就能禁止新属性的添加，原生 js 提供了 3 种方法！</p><ol><li>禁止扩展；</li><li>对象封印；</li><li>对象冻结；</li></ol><hr><p><strong>判断对象是否为可扩展：</strong><br><code>isExtensible(对象名)</code> ，返回一个布尔值，默认创建的对象为可扩展 <code>true</code>!<br>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;YangYangYang&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(person1))); <span class="comment">// true 创建的对象默认都是ture</span></span><br></pre></td></tr></table></figure><h3 id="禁止扩展：Object-preventExtensions"><a href="#禁止扩展：Object-preventExtensions" class="headerlink" title="禁止扩展：Object.preventExtensions()"></a>禁止扩展：Object.preventExtensions()</h3><p>这种方法是利用 <code>Object.preventExtensions()</code> 方法， (防止扩展的意思)，创建一个不可扩展的对象，该方法接收一个参数，就是你希望使其不可扩展的对象。一旦在一个对象上使用该方法，就永远不能再给它添加新的属性了，可以利用 <code>Object.isExtensible()</code>方法来检查 [[Extensible]] 的值。</p><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;YangYangYang&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(person1)) <span class="comment">// true 判断这个对象是否为可扩展的对象</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(person1) <span class="comment">// 强制要求使其当前对象为不可扩展</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(person1)) <span class="comment">// 所以 现在反悔为false 不可扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再尝试给person1对象添加一个方法</span></span><br><span class="line"></span><br><span class="line">person1.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sayName&#x27;</span> <span class="keyword">in</span> person1) <span class="comment">// 判断这个新添加的方法 在person1对象中存在，结果为false 因为不可扩展 以上设置没被添加到</span></span><br></pre></td></tr></table></figure><p>每一次创建一个对象的时候，都会隐式的检查该对象的 [[Extensible]] 特征，默认是可扩展。以上代码显示的将其变为不可扩展，由于不可扩展，所有上面的 <code>sayName</code> 方法永远无法添加到 <code>person1</code> 上！</p><h3 id="对象封印：Object-seal"><a href="#对象封印：Object-seal" class="headerlink" title="对象封印：Object.seal()"></a>对象封印：Object.seal()</h3><p>对象封印是创建不可扩展对象的第二种方法。<br>一个被封印的对象是不可扩展的并且其所有属性都不可配置，意味着不能给添加对象新属性，也不能删除属性或改变类型，如果一个对象被封印，只能读写它的属性。</p><p>使用 <code>Object.seal()</code> 方法来封印一个对象。当该方法被调用时，[[Extensible]] 特征被置为 <code>false</code>,其所有属性的[[Configurable]] 特征被置为 <code>false</code>。</p><p>判断对象是否被封印。<br><code>Object.isSealed(对象名)</code>，返回一个布尔值，默认是 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;YangYangYang&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(person1)); <span class="comment">// 返回false</span></span><br></pre></td></tr></table></figure><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;YangYangYang&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(person1)) <span class="comment">// true  可以扩展</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(person1)) <span class="comment">// false  没有被封印</span></span><br><span class="line"><span class="comment">// 下面对person1 对象进行封印</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(person1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(person1)) <span class="comment">// false  不能扩展</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(person1)) <span class="comment">// true  被封印</span></span><br><span class="line"><span class="comment">// 尝试给对象添加方法</span></span><br><span class="line">person1.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sayName&#x27;</span> <span class="keyword">in</span> person1) <span class="comment">// 返回结果为true 证明添加对象方法失败</span></span><br><span class="line"><span class="comment">// 尝试修改自由属性的值</span></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;Greg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>) <span class="comment">// 修改成功 可以读写</span></span><br><span class="line"><span class="comment">// 获取属性特征看看</span></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person1, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">configurable</span>) <span class="comment">// 返回false 代表不可配置！不可以删除！不可以修改特征！</span></span><br></pre></td></tr></table></figure><p>这段代码封印了 <code>person1</code>,因此不能再 <code>person1</code> 上面添加或删除属性，所有的封印对象都是不可扩展的对象，此时对 <code>person1</code> 使用 <code>Ojbect.Extensible()</code>方法将返回 false,并且试图添加 <code>sayName()</code> 会失败，而且，虽然 <code>person1.name</code> 被成功改变为新值，是因为它 <code>writable</code> 为 <code>true</code>，可以读写，但是删除它确是失败，因为它的数据属性特征 <code>configurable</code> 为 <code>false</code>,不可配置！</p><p>🔔 注意：</p><ol><li>禁止扩展：只是阻止了扩展功能，无法添加新的属性和方法。</li><li>封印对象：在阻止扩展功能的前提上，增加了不可配置，不能删除和重新配置<br>相同点：它们都是可以针对对象自有属性进行 writable 读写的！</li></ol><h3 id="对象冻结-Object-fieeze"><a href="#对象冻结-Object-fieeze" class="headerlink" title="对象冻结 Object.fieeze()"></a>对象冻结 Object.fieeze()</h3><hr><p>创建不可扩展对象的最后一种方法是冻结它。<br>如果一个对象被冻结，则不能再其上添加或删除属性，不能改变属性类型，也不能写入任何数据属性。<br>简而言之，被冻结对象是一个数据属性都为只读的被封印对象，所以 <code>Object.isExtensible()</code> 返回为 <code>false</code> (不可扩展)，而 <code>Object.isSealed()</code>返回 <code>true</code> （被封印）。<br>被冻结对象无法解冻！</p><hr><p>判断对象是否被冻结：<code>Object.isFrozen(对象名)</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;YangYangYang&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(person1)); <span class="comment">// true 可扩展</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(person1)); <span class="comment">// false 没被封印</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isPFrozen</span>(person1)); <span class="comment">// false 没被冻结</span></span><br><span class="line"><span class="comment">// 强制冻结此对象</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(person1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(person1)); <span class="comment">// false 不可扩展</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(person1)); <span class="comment">// true 被封印</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isPFrozen</span>(person1)); <span class="comment">// true 被冻结</span></span><br></pre></td></tr></table></figure><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;YangYangYang&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(person1)) <span class="comment">// true 可扩展</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(person1)) <span class="comment">// false 没被封印</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(person1)) <span class="comment">// false 没被冻结</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制冻结</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(person1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(person1)) <span class="comment">// false 不可扩展</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(person1)) <span class="comment">// true 被封印</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(person1)) <span class="comment">// true 被冻结</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试给对象添加方法</span></span><br><span class="line">person1.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sayName&#x27;</span> <span class="keyword">in</span> person1) <span class="comment">// 判断sayName在person1对象当中吗 结果为false 证明没添加到对象中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试给自由属性读写 改变属性值</span></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;杨大哥&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>) <span class="comment">// 结果依然是冻结之前定义的已有name 证明读写失败  writable为false 不可读写！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性name的类型特征</span></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person1, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">configurable</span>) <span class="comment">//  false 不可配置</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">writable</span>) <span class="comment">// false 不可读写</span></span><br></pre></td></tr></table></figure><p>🔔 注意：被冻结的对象仅仅只是对象在某个时间点上的快照，其用途有限且极少使被使用；使用的时候注意，不可扩展，对象封印，对象冻结的特性来根据需求选择！<br>冻结对象较于封印对象 多了属性 [[Writable]] 为 <code>false</code> 不可写！ 只能读~</p><p>冻结/封印/扩展的时候注意是冻结实例对象还是冻结构造函数的原型，但是常规的原型引用的目的就是为了共享，所以原型的冻结是没必要的，一般原生提供的 <code>Object</code> 顶级对象的原型 就是可以提供修改的 只是不能删除(不可配置 <code>configurable</code>)</p><h2 id="模块模式和暴露模块模式"><a href="#模块模式和暴露模块模式" class="headerlink" title="模块模式和暴露模块模式"></a>模块模式和暴露模块模式</h2><hr><p>模块模式：（单个对象，字面量对象）<br>模块模式是一种用于创建拥有私有数据的单件对象的模式。基本做法是使用立即执行函数表达（IIFE）来返回一个对象。IIFE 是一种被定义后立即调用并产生结果的函数表达，该函数表达可以包括任意数量的本地 变量，它们在函数外不可见。因为返回的对象被定义在函数内部，对象的方法可以访问这些数据。(IIFE 定义的所有的对象都可以访问同样的本地变量)以这种方式访问私有数据的方法被称为特权方法。</p><hr><p>栗：基本格式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yourObj = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有数据 变量</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 公有的方法和属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>该模式创建了一个匿名函数并立即执行。这种立即执行函数意味着仅存在于被调用的瞬间，一旦执行完毕立即销毁。<br>模块模式允许使用普通变量作为非公有对象属性。<br>通过创建闭包函数作为对象方法来操作它们。<br>闭包函数就是一个可以访问其他作用域外部数据的普通函数。</p><p>举例来说：<br>当你在一个函数中访问一个全局对象，比如网页浏览器的 window 对象，该函数就是在访问其欧用于的变量。</p><p>区别是：<br>在模块模式里，变量是定义在 IIFE(立即执行表达式函数)中，而访问变量的函数也定义在 IIFE 中。</p><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">25</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Yang&#x27;</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> age</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">growOLder</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      age++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>) <span class="comment">// Yang</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getAge</span>()) <span class="comment">// 25</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span> <span class="comment">//</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getAge</span>()) <span class="comment">// 所以结果还是 25</span></span><br><span class="line">person.<span class="title function_">growOlder</span>() <span class="comment">// 执行一次++函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getAge</span>()) <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p>这段代码使用模块创建了 <code>person</code> 对象。<br>变量 <code>age</code> 就是该对象的一个私有属性。<br>它无法被外界直接访问，但可以通过对象方法来操作。<br>该对象上有有两个特权方法：<code>getAge()</code>读取变量 <code>age</code> 的值，<code>growOlder()</code> 让 <code>age</code> 自增.<br>这两个方法都可以直接访问变量 <code>age</code>，因为它们都定义了同一个 IIFE 内。</p><h3 id="暴露模块模式"><a href="#暴露模块模式" class="headerlink" title="暴露模块模式"></a>暴露模块模式</h3><p>它将所有的变量和方法都组织在 IIFE 的顶部，然后将它们设置到需要被返回的对象上。</p><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">25</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">growOlder</span>(<span class="params"></span>) &#123;</span><br><span class="line">    age++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以上都是本地的 私有的</span></span><br><span class="line">  <span class="comment">// 下面是决定将哪些私有的 本地的 方法或属性 暴露出去</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Yang&#x27;</span>,</span><br><span class="line">    <span class="attr">getAge</span>: getAge,</span><br><span class="line">    <span class="attr">growOlder</span>: growOlder,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>在暴露模块模式中，<code>age,getAge()</code> 和 <code>growOlder()</code> 都被定义成 IIFE 的本地对象。<br>然后 <code>getAge()</code> 和<code>growOlder()</code> 函数被设置到返回的对象中，有效地对外界进行了 “暴露”。<br>也就是说，只能对暴露出来的这些属性和方法进行操作！</p><h3 id="构造函数的私有成员"><a href="#构造函数的私有成员" class="headerlink" title="构造函数的私有成员"></a>构造函数的私有成员</h3><p>模块模式在定义单 对象的私有属性上十分有效，但对于同样需要私有属性的自定义类型，需要用构造函数类型的模块模式来创建。</p><p>栗：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 定义一个只能在Person构造函数内部访问的变量</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">25</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">growOlder</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    age++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Yang&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>) <span class="comment">// Yang</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getAge</span>()) <span class="comment">// 25</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getAge</span>()) <span class="comment">// 25</span></span><br><span class="line">person.<span class="title function_">growOlder</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getAge</span>()) <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p>在这段代码中，<code>Person</code> 构造函数有一个本地变量 <code>age</code>。<br>该变量被用于 <code>getAge()</code>和 <code>growOlder()</code>方法，当你创建 <code>Person</code> 的一个实例时，该实例接收其自身的 <code>age</code> 变量、<code>getAge()</code> 方法和 <code>growOlder()</code>方法，这种做法在很多方面类似模块模式，构造函数创建一个本地作用域并返回 <code>this</code> 对象。<br>将方法直接放在对象实例上不如放在原型对象有效，但是如果需要实例私有的数据，这是唯一的手段！</p><p><strong>所有实例可共享的私有数据：</strong><br>就好像它被定义在原型对象里那样，需要结合模块模式和构造函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 每个人的年龄都一样</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">25</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">InnerPerson</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">InnerPerson</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">InnerPerson</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">growOlder</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    age++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">InnerPerson</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Yang&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Wang&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>) <span class="comment">// Yang</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getAage</span>()) <span class="comment">// 25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>) <span class="comment">// Wang</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">getAge</span>())</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="comment">//  调用++函数</span></span><br><span class="line">person1.<span class="title function_">growOlder</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getAge</span>()) <span class="comment">// 26</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">getAge</span>()) <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p>在这段代码中，<code>InnerPerson</code> 构造函数被定义在一个 IIFE 中。<br>变量 <code>age</code> 被定义在构造函数外并被两个原型对象的方法使用。<br>IIFE 返回 <code>InnerPerson</code> 构造函数作为全局作用域里的 Person 构造函数。<br>最终，Person 的全部实例得以共享 <code>age</code> 变量，所以在一个实例上的改变自动影响另外一个。</p></article><div class="trm-reward"><span class="trm-reward-btn trm-glow" onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'><i class="iconfont fas fa-hand-holding-usd"></i></span><p class="trm-reward-comment">我很可爱，请给我钱</p><div id="qr" style="display:none"><div style="display:inline-block"><a rel="noopener" href="https://cheny-chenyu.oss-cn-chengdu.aliyuncs.com/img/weixin-pay.png" target="_blank"><img src="https://cheny-chenyu.oss-cn-chengdu.aliyuncs.com/img/weixin-pay.png" alt="微信" loading="lazy"></a><p>微信</p></div><div style="display:inline-block"><a rel="noopener" href="https://cheny-chenyu.oss-cn-chengdu.aliyuncs.com/img/zhifubao-pay.png" target="_blank"><img src="https://cheny-chenyu.oss-cn-chengdu.aliyuncs.com/img/zhifubao-pay.png" alt="支付宝" loading="lazy"></a><p>支付宝</p></div></div></div><ul class="trm-post-copyright"><li class="trm-post-copyright-author"><strong>本文作者：</strong> CHENY</li><li class="trm-post-copyright-link"><strong>本文链接：</strong> <a id="original-link" href="https://www.yangchenyu.com/native/object/" title="前端原生【对象】Object">https://www.yangchenyu.com/native/object/</a></li><li class="trm-post-copyright-license"><strong>版权声明：</strong> 本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 ">CC BY-NC-SA 4.0</a> 许可协议。</li></ul></div><div id="post-next-prev" class="row"><div class="col-lg-12"><h5 class="trm-title-with-divider">其他文章 <span data-number="02"></span></h5></div><div class="col-lg-6"><div class="trm-blog-card trm-scroll-animation" data-scroll data-scroll-offset="40"><a href="/native/array/" class="trm-cover-frame trm-anima-link"><img alt="cover" class="no-fancybox" src="https://cheny-chenyu.oss-cn-chengdu.aliyuncs.com/blog/20230320130751.png"></a><div class="trm-card-descr"><div class="trm-label trm-category trm-mb-20"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%8E%9F%E7%94%9F/">前端原生</a></div><h5><a href="/native/array/" class="trm-anima-link">前端原生【数组】Array</a></h5><div class="trm-divider trm-mb-20 trm-mt-20"></div><ul class="trm-card-data trm-label"><li>19/10/14</li><li>14:56</li></ul></div></div></div></div><div class="trm-divider footer-divider"></div><footer class="trm-scroll-animation" data-scroll data-scroll-offset="50"><div class="trm-footer-item"><span>© 2019- 2024</span> <span class="footer-separator" data-separator=" · "></span> <span class="trm-accent-color">CHENY</span></div><div class="trm-footer-item"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.2 </span><span class="footer-separator" data-separator=" | "></span> <span>主题 - <a rel="noopener" href="https://github.com/MaLuns/hexo-theme-async" target="_blank">Async</a> v1.2.14</span></div><div class="trm-footer-item">博客已萌萌哒运行 <span id="since" class="trm-accent-color"></span> 天</div></footer><script>function show_date_time(){BirthDay=new Date("11/19/2019 17:00:00"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),msPerDay=864e5,day=Math.floor(timeold/msPerDay),since.innerHTML=day}show_date_time()</script></div></div></div></div></div><div class="trm-fixed-container" data-scroll data-scroll-sticky data-scroll-target=".locomotive-scroll__sticky-target" data-scroll-offset="-10"><div class="trm-fixed-btn" data-title="阅读模式" onclick="switchReadMode()"><i class="iconfont fas fa-book-reader"></i></div></div></div></div></div></div><div id="trm-back-top" class="trm-back-top" data-title="回到顶部"><i class="iconfont fas fa-arrow-up"></i></div><div class="trm-search-popup"><div class="trm-search-header"><span class="trm-search-popup-btn-close"><i class="iconfont fas fa-times"></i></span></div><div class="form trm-search-form"><input class="trm-search-input" type="text" placeholder="搜索..."></div><div class="trm-search-result-container"></div></div><script src="https://unpkg.com/swup@2.0.19/dist/swup.min.js"></script><script src="https://unpkg.com/locomotive-scroll@4.1.4/dist/locomotive-scroll.min.js"></script><script src="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script><script src="/js/plugins/typing.js?v=1.2.14"></script><script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js"></script><script src="/js/plugins/local_search.js?v=1.2.14"></script><script src="//code.tidio.co/het7qhit6brc6kwukrbcbtltwr9xhcty.js" async></script><script id="async-script" src="/js/main.js?v=1.2.14"></script></body></html>